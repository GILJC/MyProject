셸 스크립트 ~~ 할때는
대문자로 쓰는게 전통.
다들 대문자로 씀.


bash,셸 프로그래밍 할때는 항상 맨 위에 이렇게 쓰는데,
#!/bin/bash


현재 이 스크립트가 bash가 아닐 때에는
bash를 불러와서 실행을 해라     ->  bash shell을 실행한게 다른거라면 bashs hell 에서 실행하라는 의미.

그래서 얘는 써주는게 좋다.

일반적인 주석은 # 하고 쓰면 됨

VAR1=
여기서 space 띄면 안됨. 다 붙여야함.

---script01
#!/bin/bash

# This is variable test

VAR1="Hello, world!"
echo $VAR1
---

script01
실행하면 안됨.
PATH에서 찾으면서 내가 실행시킬 파일을 찾음.
근데 찾을 수 없다는거


$PATH
해보면 여기에 없으니 안됨.
그렇다고 파일 하나씩 돌릴때마다, 여기에 등록할 순 없음
-> 실행할때, 컴퓨터에 파일 위치 알려주면 됨

=>
./script01
이러면 실행이 됨'


---script02
#!/bin/bash

for i in 1 2 3
do
    echo $i
done
------------------------

---script03
#!/bin/bash

for i in $(ls)
do
    echo $i
done
------------------------

---script04
for i in {0..9}
do
    scho $i
done
------------------------

---script05
#!/bin/bash

for i in {0..9..2}  # from 0 to 9, step2
do
    echo $i
done
------------------------


	$0 - 현재 스크립트의 파일명
	$n - 쉘 스크립트 실행 시 주는 인자($1 부터 )
	$# - 스크립트에 제공된 인자의 수
	$* - 스크립트에 제공된 모든 인자
	$@ - $*과 같지만 개별 묶음
	$? - 마지막 명령어 실행 종료 코드
	$$ - 현재 실행되는 쉘스크립트의 PID
	$! - 마지막 백그라운드 명령어의 PID



---script06
#/bin/bash

echo "File Name: $0"
echo "First Parameter: $1"
echo "Second Parameter: $2"
echo "Quoted Values: $@"
echo "Quoted Values: $*"
echo "Total Number of Parameters: $#"
echo "Current shell script PID: $$"
------------------------

script06 -> 이건 실행할때 다음과 같이 실행해보자
[gil@script]./script -6 abc kim 123 school

>>>
[gil@script]./script06 -6 abc kim 123 school
File Name: ./script06
First Parameter: -6
Second Parameter: abc
Quoted Values: -6 abc kim 123 school
Quoted Values: -6 abc kim 123 school
Total Number of Parameters: 5
Current shell script PID: 2464
[gil@script]


이렇게 출력됨.

골뱅이(@)와 별(*)은 차이를 모르겠음.  따로 볼것.

------------------------

---script07  ->  골뱅이(@)와 별(*)
#!/bin/bash

for TOKEN in $*
do
    echo $TOKEN
done
------------------------
>>>
[gil@script][gil@script]./script07 My name is Kate Morgan
My
name
is
Kate
Morgan
[gil@script]

------------------------

---script08  ->  골뱅이(@)와 별(*)
#!/bin/bash

for TOKEN in $@
do
    echo $TOKEN
done
------------------------
[gil@script]./script08 My name is Kate Morgan
My
name
is
Kate
Morgan
[gil@script]
------------------------

---script09
#!/bin/bash

for TOKEN in "$*"
do
    echo $TOKEN
done
------------------------
[gil@script]./script09 My "name is Kate" Morgan
My name is Kate Morgan
[gil@script]





vim 설치

sudo apt install vim

which vim
/usr/bin/vim


--
vim 글자 색 변경

cd /usr/share/vim

cd vim81/colors/

색 바꿀때,
여기서 나오는 파일 이름을 집어넣으면 됨(.vmi 빼고)

koehler  <- 이걸 넣어봄

(홈디렉터리에서)
vi .vimrc

set cindent
set tabstop=4
set shiftwidth=4
set expandtab
(여기서 맨 아래에 추가)

colorscheme koehler








---script10
#!/bin/bash

for TOKEN in "$@"
do
    echo $TOKEN
done
------------------------
[gil@script]./script10 My "name is Kate" Morgan
My
name is Kate
Morgan
[gil@script]



()()()()()()()()
if를 이렇게 씀

if["$#" -lt 1]   <- 전체 개수가 1보다 작으면 = 파라미터를 안주면


---script11
#!/bin/bash

if [ "$#" -lt 1 ]   <-  if 띄고, [ asd ]   <- 괄호 []  사이에도 하나씩 띄어줘야함
then
    echo "$# is illegal number of parameters."
    echo "Usage: $0 [options]"
    exit 1  <-  스크립트 종료
fi

ARGS=("$@")     <-  들어온 인자 배열로 담음
for((c=0;c<$#;c++))
do
    echo "$c th parameter = ${ARGS[$c]}"     <-  이렇게 꺼내옴
done
------------------------
>>>
[gil@script]./script11 java python c++
0 th parameter = java
1 th parameter = python
2 th parameter = c++
[gil@script]

------------------------


mkdir c-language
폴더 만듬
cd c-language


------------------------

정수 2개 덧셈하는 함수를 C로 만들어봄

vi int_add.c

---int_add.c
int int_add(int a, int b)
{
    return a + b;
}
------------------------

---cal_main.c
#include <stdio.h>

extern int_add(int, int);    <-  외부 파일에 이런 함수가 있다, 라고 이런식으로 알려줘야 함
int main(void)
{
    int num1 = 10, num2 = 30;

    printf("num1 + num2 = %d\n", int_add(num1, num2));

    return 0;
}
------------------------


[gil@c-language]gcc -c int_add.c
[gil@c-language]gcc -c cal_main.c
[gil@c-language]ls -l
합계 16
-rw-rw-r-- 1 gil gil  170 10월 15 14:10 cal_main.c
-rw-rw-r-- 1 gil gil 1784 10월 15 14:15 cal_main.o
-rw-rw-r-- 1 gil gil   51 10월 15 14:06 int_add.c
-rw-rw-r-- 1 gil gil 1384 10월 15 14:15 int_add.o
[gil@c-language]



-> 이러면 .o 파일이 생김 -> object 파일

실행파일명을 먼저 적고(cal_main이라고 할거임), 2개를 입력으로 받을거임

그러면 녹색파일이름이 생김
[gil@c-language]gcc -o cal_main int_add.o cal_main.o
[gil@c-language]ls -l
합계 36
-rwxrwxr-x 1 gil gil 16768 10월 15 14:17 cal_main  <- 요놈
-rw-rw-r-- 1 gil gil   170 10월 15 14:10 cal_main.c
-rw-rw-r-- 1 gil gil  1784 10월 15 14:15 cal_main.o
-rw-rw-r-- 1 gil gil    51 10월 15 14:06 int_add.c
-rw-rw-r-- 1 gil gil  1384 10월 15 14:15 int_add.o
[gil@c-language]

-> c언어 소스를 링킹해서 실행파일로 만드는 방법

[gil@c-language]./cal_main
num1 + num2 = 40
[gil@c-language]



--------
소스가 50개 되면 일일이 컴파일, 묶을 순 없다.
이걸 자동화 하는게
->
make
임

make 유틸리티는 설정 파일이 있어야함 -> 어떻게 할건지 설정을 해줘야함
1. makefile
2. Makefile

2개가 있는데, 뭘 쓸지는 취향의 문제.
하나만 있으면 되는데, 둘 다 있으면 안됨..

make 설정 파일은 소스 안에 섞여있게 되는데,,
Makefile로 만들면 <- 대문자가 구분이 잘되서 이걸 선호함,.


---

강제로 다른 이름으로 해서 읽을 순 있는데ㅡ,
-f 옵션을 줘야함
-f 옵션을 안주면 기본적으로 먹는게  Makefile

vi Makefile
---Makefile
cal_main:   int_add.o cal_main.o
    gcc -o cal_main int_add.o cal_main.o

int_add.o:  int_add.c
    gcc -c int_add.c

cal_main.o: cal_main.c
    gcc -c cal_main.c
------------------------

콜론(:) 앞의 놈(cal_main) -> target
 "       뒤  "  	       -> source
gcc~~ 로 만든다.
..
int_add.o는 int_add.c 로 만든다
gcc -c int _add.c  의 방식으로

------------------------

.o 파일, cal_main 날림

rm *.o

-rwxrwxr-x 1 gil gil 16768 10월 15 14:17 cal_main
-rw-rw-r-- 1 gil gil   170 10월 15 14:10 cal_main.c
-rw-rw-r-- 1 gil gil  1784 10월 15 14:15 cal_main.o
-rw-rw-r-- 1 gil gil    51 10월 15 14:06 int_add.c
-rw-rw-r-- 1 gil gil  1384 10월 15 14:15 int_add.o
[gil@c-language]./cal_main
num1 + num2 = 40
[gil@c-language]vi Makefile
[gil@c-language]rm *.o
[gil@c-language]rm cal_main
[gil@c-language]ls -l
합계 12
-rw-rw-r-- 1 gil gil 164 10월 15 14:25 Makefile
-rw-rw-r-- 1 gil gil 170 10월 15 14:10 cal_main.c
-rw-rw-r-- 1 gil gil  51 10월 15 14:06 int_add.c
[gil@c-language]


make -f 파일명 <- 을 주던가

make 하면 됨

!!!!!!
[gil@c-language]vi ~/.vimrc
열어서 
set expandtab -> 날림
>>>
set cindent
set tabstop=4
set shiftwidth=4
colorscheme koehler

---
vi Makefile

열어서 앞의 빈칸 4개 지우고 tab으로 교체
>>>
cal_main:   int_add.o cal_main.o
    gcc -o cal_main int_add.o cal_main.o

int_add.o:  int_add.c
    gcc -c int_add.c

cal_main.o: cal_main.c
    gcc -c cal_main.c

:wq 저장

----
[gil@c-language]make
gcc -c int_add.c
gcc -c cal_main.c
gcc -o cal_main int_add.o cal_main.o
[gil@c-language]

잘 실행됨


-> 실행 체크해서 바뀐놈만 업데이트해줌
안바뀐놈은 냅둠

make: 'cal_main'은(는) 이미 업데이트되었습니다.
[gil@c-language]

파일이 몇십, 몇백개쯤 되면,
사람 손으로 일일이 찾아서 하기 어려움.  -> 자동화  -> 이래서 make 쓰는 것


[gil@c-language]./cal_main
num1 + num2 = 40
[gil@c-language]

------------------------
코딩 하다보면
싸그리 깨끗하게 전체를 build 하고 싶을때가 있음.

.o파일이 실행파일보다 나중에 생긴것.


vi Makefile
파일 열어서
다음 추가

clean:
    rm cal_main cal_main.o int_add.o

그러면 다음과 같이

[gil@c-language]vi Makefile
[gil@c-language]ls -l
합계 40
-rw-rw-r-- 1 gil gil   197 10월 15 14:37 Makefile
-rwxrwxr-x 1 gil gil 16768 10월 15 14:30 cal_main
-rw-rw-r-- 1 gil gil   170 10월 15 14:10 cal_main.c
-rw-rw-r-- 1 gil gil  1784 10월 15 14:30 cal_main.o
-rw-rw-r-- 1 gil gil    51 10월 15 14:06 int_add.c
-rw-rw-r-- 1 gil gil  1384 10월 15 14:30 int_add.o
[gil@c-language]make clean   <-  clean에 지정한 파일들 삭제
rm cal_main cal_main.o int_add.o
[gil@c-language]ls -l
합계 12
-rw-rw-r-- 1 gil gil 197 10월 15 14:37 Makefile
-rw-rw-r-- 1 gil gil 170 10월 15 14:10 cal_main.c
-rw-rw-r-- 1 gil gil  51 10월 15 14:06 int_add.c
[gil@c-language]make   <-  다시 make 함
gcc -c int_add.c
gcc -c cal_main.c
gcc -o cal_main int_add.o cal_main.o
[gil@c-language]ls -l
합계 40
-rw-rw-r-- 1 gil gil   197 10월 15 14:37 Makefile
-rwxrwxr-x 1 gil gil 16768 10월 15 14:38 cal_main
-rw-rw-r-- 1 gil gil   170 10월 15 14:10 cal_main.c
-rw-rw-r-- 1 gil gil  1784 10월 15 14:38 cal_main.o
-rw-rw-r-- 1 gil gil    51 10월 15 14:06 int_add.c
-rw-rw-r-- 1 gil gil  1384 10월 15 14:38 int_add.o
[gil@c-language]

------------------------
vi Makefile
다음 추가.
all:    cal_main
-> make해도 어차피 할일 없어서 변화 없음..



----
[gil@c-language]touch *.c
-> 터치한것.
  (?)

---
clean 과 비교하기 위해,
make all
이라고 씀.
해도 그만, 안해도 그만

여기까지가.
리눅스등의 make의 공통기능




[다음부터]
-------------------------------------------GNU  make의 확장 기능
vi Makefile 열고

cal_main:   int_add.o cal_main.o
    gcc -o $@ int_add.o cal_main.o  <-  $@  <- 현재 단계에서의 target을 굳이 안쓰고 $@로 대체한 것

%.o:  %.c
    gcc -c $<

clean:
    rm cal_main cal_main.o int_add.o

all:    cal_main

---
  $@  <- 현재 단계에서의 target을 굳이 안쓰고 $@로 대체한 것
---

cal_main:   int_add.o cal_main.o
    gcc -o cal_main int_add.o cal_main.o  ->  gcc -o $@ int_add.o cal_main.o
변경한것.

-------
vi 문법,..
C -> 현재 커서부터 라인의 끝까지 싸그리 바꿔버리겠다

$<   ->   날짜가 최신인놈을 바꿔버리겠다.

($< : 타겟을 생성하기 위해 가장 왼쪽에 기술된 첫번째 오브젝트)

--- --- ---

일반적으로 리눅스의 touch 명렁어는 빈 파일을 작성하거나

파일의 타임스탬프를 변경하는 용도로 사용한다.

--- --- ---
[gil@c-language]touch *.c
[gil@c-language]ls -l
합계 40
-rw-rw-r-- 1 gil gil   191 10월 15 14:54 Makefile
-rwxrwxr-x 1 gil gil 16768 10월 15 14:44 cal_main
-rw-rw-r-- 1 gil gil   170 10월 15 14:54 cal_main.c
-rw-rw-r-- 1 gil gil  1784 10월 15 14:44 cal_main.o
-rw-rw-r-- 1 gil gil    51 10월 15 14:54 int_add.c
-rw-rw-r-- 1 gil gil  1384 10월 15 14:44 int_add.o

[gil@c-language]make
gcc -c int_add.c
gcc -c cal_main.c
gcc -o cal_main int_add.o cal_main.o

[gil@c-language]ls -l
합계 40
-rw-rw-r-- 1 gil gil   191 10월 15 14:54 Makefile
-rwxrwxr-x 1 gil gil 16768 10월 15 14:54 cal_main
-rw-rw-r-- 1 gil gil   170 10월 15 14:54 cal_main.c
-rw-rw-r-- 1 gil gil  1784 10월 15 14:54 cal_main.o
-rw-rw-r-- 1 gil gil    51 10월 15 14:54 int_add.c
-rw-rw-r-- 1 gil gil  1384 10월 15 14:54 int_add.o

[gil@c-language]


---------
int_add.o:  int_add.c
    gcc -c $<

cal_main.o: cal_main.c
    gcc -c $<

( ->  change word  (cw) -> % )

%.o:  %.c
    gcc -c $<

로 바꿈.

이러면 
소스코드 파일이 수백가지라도
1줄로 정리가 됨
= 한번에 다 바꿔줌

[gil@c-language]make clean
rm cal_main cal_main.o int_add.o
[gil@c-language]make all
gcc -c int_add.c
gcc -c cal_main.c
gcc -o cal_main int_add.o cal_main.o
[gil@c-language]ls -l
합계 40
-rw-rw-r-- 1 gil gil   179 10월 15 15:12 Makefile
-rwxrwxr-x 1 gil gil 16768 10월 15 15:12 cal_main
-rw-rw-r-- 1 gil gil   170 10월 15 14:54 cal_main.c
-rw-rw-r-- 1 gil gil  1784 10월 15 15:12 cal_main.o
-rw-rw-r-- 1 gil gil    51 10월 15 14:54 int_add.c
-rw-rw-r-- 1 gil gil  1384 10월 15 15:12 int_add.o
[gil@c-language]


--------------------------------

vi ~/.bashrc
맨 아랫줄()에 다음 추가
set -o vi

=
PS1="[\u@\W]"
set -o vi

(:1 -> 첫째줄로 이동)


[gil@c-language]source ~/.bashrc
로 적용
(참고)
( . ~/.bashrc   로도 적용 가능. 같은 뜻 )


-----------------------------------

vi Makefile

소스파일이 늘면,  Makefile 의 소스코드가  게속 늘어남
간단히 하는 방법 -> 변수를 쓰면 됨

맨 윗줄에 변수 추가(O) , (o는 아랫줄에 추가)

cal_main:   int_add.o cal_main.o
    gcc -o $@ int_add.o cal_main.o

%.o:  %.c
    gcc -c $<

clean:
    rm cal_main cal_main.o int_add.o

all:    cal_main

에서 변경
->
OBJS=int_add.o cal_main.o

cal_main:   $(OBJS)
    gcc -o $@ $(OBJS)   <-  $@  -> 이놈은 cal_main 을 의미함

%.o:  %.c
    gcc -c $<

clean:
    rm cal_main $(OBJS)

all:    cal_main



(C로 뒷줄 전부 변경 -> $(OBJS) 추가 -> 점(.) 으로 방금 입력한거 그대로 입력 가능)

[gil@c-language]make clean
rm cal_main int_add.o cal_main.o

[gil@c-language]make all
gcc -c int_add.c
gcc -c cal_main.c
gcc -o cal_main int_add.o cal_main.o

[gil@c-language]


++++
----------
이상태에서 이스케이프를 한번만 눌러줌 -> vi모드로 들어간거 (화면 변화는 없지만..)
-> /vi M  -> 라고 치면 -> vi Makefile  -> 을 찾아줌  -> enter 치면 들어감..
-----------

vi Makefile

OBJS=int_add.o cal_main.o

cal_main:   $(OBJS)
    gcc -o $@ $(OBJS)

%.o:  %.c
    gcc -c $<

clean:
    rm cal_main $(OBJS)

all:    cal_main


---->  에서 변경
OBJS=int_add.o cal_main.o
TARGET=cal_main

$(TARGET):   $(OBJS)
    gcc -o $@ $(OBJS)

%.o:  %.c
    gcc -c $<

clean:
    rm $(TARGET) $(OBJS)

all:    $(TARGET)

-----------------------------------
[gil@c-language]make clean
rm cal_main int_add.o cal_main.o

[gil@c-language]make all
gcc -c int_add.c
gcc -c cal_main.c
gcc -o cal_main int_add.o cal_main.o

[gil@c-language]


-----------------------------------
vi Makefile
여기서 -o  -> 옵션도 변수처리 할 것

OBJS=int_add.o cal_main.o
TARGET=cal_main

$(TARGET):   $(OBJS)
    gcc -o $@ $(OBJS)

%.o:  %.c
    gcc -c $<

clean:
    rm $(TARGET) $(OBJS)

all:    $(TARGET)

---> 변경

OBJS=int_add.o cal_main.o
TARGET=cal_main
OFLAGS=-o
CFLAGS=-c
CC=gcc  
( 이것 추가 )  =  여기까진 보통 많이들 함

===> 변경 완성본
OBJS=int_add.o cal_main.o
TARGET=cal_main
OFLAGS=-o
CFLAGS=-c
CC=gcc

$(TARGET):   $(OBJS)
    $(CC) $(OFLAGS) $@ $(OBJS)

%.o:  %.c
    $(CC) $(CFLAGS) $<

clean:
    rm $(TARGET) $(OBJS)

all:    $(TARGET)

(-c, -o gcc  부분을 변수로 변경  -> 나중에 변수만 바꾸면 알아서 다 바뀌기 때문에 편함)



실제로 Makefile 받으면 다 이런식으로 되어있음.
나중에 하둡 설치할때, Makefile 볼때 있음,
-----------------------------------------------------




[][][][][][][] AWK [][][][][][][][][]

home

cd source/script

vi awkfile

---awkfile
James	Dean	176 1974/10/24	2345687
Matt	Daemon	171 1980/04/02	2323872
Kate	Moss	179 1975/05/21	2187461
Harrison	Ford	183 1965/08/12	2398381
----------------------

[gil@script]awk '{print $0}' awkfile	 #  $0  ->  라인 전체
James   Dean    176 1974/10/24  2345687
Matt    Daemon  171 1980/04/02  2323872
Kate    Moss    179 1975/05/21  2187461
Harrison        Ford    183 1965/08/12  2398381
------------
awk 스크립트 언어
awkfile 을 읽어서 라인 전체를 출력하라

$1  -> 첫번째 컬럼
$2  -> 2번째 컬럼

[gil@script]awk '{print $1}' awkfile
James
Matt
Kate
Harrison

[gil@script]awk '{print $2}' awkfile
Dean
Daemon
Moss
Ford


----------
이 단어가 포함된 라인을 골라내라

awk '/Moss/' awkfile

[gil@script]awk '/Moss/' awkfile
Kate    Moss    179 1975/05/21  2187461


---------------
at란 문자가 들어있는 라인을 찾아서 print해라 -> 어떻게? -> \t 텝을 하고, Good Morning, 하고 -> $1, $2 출력하라 / awkfile에서

[gil@script]awk '/at/{print "\tGood Morning, " $1, $2}' awkfile
        Good Morning, Matt Daemon
        Good Morning, Kate Moss

내용을 찾고, 편집, 조작해서 출력할 수도 있음.

----------------

%-20  ->  20칸 문자를 잡아서 왼쪽정렬

%4d\n  ->  4자리 정수로 쓰고, 한칸 띄움

[gil@script]awk '{printf "The name is %-20s Height is %4d\n", $1" "$2, $3}' awkfile
The name is James Dean           Height is  176
The name is Matt Daemon          Height is  171
The name is Kate Moss            Height is  179
The name is Harrison Ford        Height is  183

-------------------




스타트가 d인놈 찍기
[gil@etc]ls -l | awk '/^[d]/{print $0}'
drwxr-xr-x  7 root root    4096  8월 19 19:41 NetworkManager
drwxr-xr-x  2 root root    4096  8월 19 19:41 PackageKit
drwxr-xr-x  2 root root    4096  8월 19 19:40 UPower
drwxr-xr-x 11 root root    4096  8월 19 19:42 X11

[gil@etc]ls -l | awk '/^[^d]/{print $0}'
합계 1100
-rw-r--r--  1 root root    3028  8월 19 19:29 adduser.conf
-rw-r--r--  1 root root     401  7월 17  2019 anacrontab
-rw-r--r--  1 root root     433 10월  2  2017 apg.conf

스타트가 l인놈 찍기 (?)  ->  link 파일만 찍기
ls -l | awk '/^[l]/{print $0}'


일반 파일만 찍기
[gil@etc]ls -l | awk '/^[-]/{print $0}'
-rw-r--r--  1 root root    3028  8월 19 19:29 adduser.conf
-rw-r--r--  1 root root     401  7월 17  2019 anacrontab
-rw-r--r--  1 root root     433 10월  2  2017 apg.conf



[gil@etc]ls -l | wc -l
225

워드카운트. 라인의 갯수



[gil@etc]ls -l | awk '/^[-]/{print $0}' | wc -l
91
-> 일반 파일의 라인 갯수?



가장 최근에 변경된 파일을 찾고 싶을 때,
역으로 (reverse)로 sorting하면 됨
r 을 붙여주면 가장 최근파일이 제일 아래에 나옴 (목록이 많을때, 가장 최근 파일 보고 싶을 때)

ls -lrt




명령어 옵션 까먹었을때 -> 메뉴얼 보면 됨
ex)  man ls  -> ls의 메뉴얼 = 각종 옵션 들 나옴
(q 하면 빠져나옴)



cd ~/source/script


ls -l | awk 'BEGIN{print"<sum of files>"}{sum+=$5}END{print sum}'
BEGIN  ->  최초로 하라 -> 최초로 뭘 할거냐
sum+=$5  ->  sum이라는 변수에 계속 5번째 칼럼 값을 누적하라
END,  마지막에 print sum을 찍어라

[gil@script]ls -l | awk 'BEGIN{print"<sum of files>"}{sum+=$5}END{print sum}'
<sum of files>
5162


---
sum이 아니라 평균 찍어라.
[gil@script]ls -l | awk 'BEGIN{print"<sum of files>"}{sum+=$5}END{print sum/NR}'
<sum of files>
368.714

총합이 아니라 평균 = 갯수로 나눠야,
마지막 라인번호 = 전체 갯수



이것들을 파일로 만들기

vi awk-script
---awk-script
BEGIN{print"<sum of files>"}
{sum+=$5}
END{print sum/NR}


이렇게 보기 좋게 짤 수도 있음


라인을 붙이고 싶을때,
J
붙이고 싶은 라인에 커서들 두고  J(대문자) 입력하면 붙음
BEGIN{print"<sum of files>"} {sum+=$5} END{print sum/NR}
대신 1칸이 띄어짐




ls -l | awk -f awk-script

복잡한 스크립트는 파일로 짠 다음에 파일로 불러오면 된다.

[gil@script]vi awk-script
[gil@script]ls -l | awk -f awk-script
<sum of files>
347.933



---
vi 명령어

물결 (~)  로 통과시키면
대문자는 소문자로 , 소문자는 대문자로
변경 됨

then  --( ~ )->  THEN
Usage	        uSAGE


----

(기타)

PATH에 걸려있는것중에 다음을 찾는 것

which python3

[gil@script]which python3
/usr/bin/python3

 (Path에 안걸려있으면 찾을 수 없음)


----

[참고..] python3은 미리 깔려있음.

[gil@script]python3
Python 3.8.10 (default, Sep 28 2021, 16:10:42)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> quit()

[gil@script]




